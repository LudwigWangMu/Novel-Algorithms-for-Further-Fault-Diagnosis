# Find the vertices with intact diagnosis capability in AN with good detection ability
# Only for specific algorithms

# find the decGood node in AN:
def decFaultFree(self):
    # print("Looking for vertices with intact diagnosis capability in AN")
    self.faultFreeSet = [] # This is diagnosed vertices with intact diagnosis capability in AN by Algorithm 1. The result of self.faulFreeSetAN = [] generated by the previous network is likely to be the same.
    bad_list=[]
    #The method of this part is: traverse every neighbor of the G_AN_H network, and put the qualified AN vertices into a set called faultFreeSet.

    for node in self.G_AN_H:
        for AN_node_id in node.neighbors[1]:
            if AN_node_id in bad_list:
                continue
            if self.Algorithm1(self.AN[AN_node_id], node):
                for node_id in self.AN[AN_node_id].neighbors[1]:
                    if not self.Algorithm1(self.AN[AN_node_id], self.AN[node_id]):
                        bad_list.append(AN_node_id)
                        break
                if AN_node_id in bad_list: continue
            #if self.AN[AN_node_id].returnDF():
                if self.AN[AN_node_id] not in self.faultFreeSet:
                    self.faultFreeSet.append(self.AN[AN_node_id])
            else:
                bad_list.append(AN_node_id)
                if self.AN[AN_node_id] in self.faultFreeSet:
                    self.faultFreeSet.remove(self.AN[AN_node_id])

    return self.faultFreeSet